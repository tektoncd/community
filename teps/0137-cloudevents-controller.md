---
status: implementable
title: CloudEvents controller
creation-date: '2023-06-19'
last-updated: '2023-07-31'
authors:
- '@afrittoli'
collaborators: []
---

# TEP-0137: CloudEvents controller
---

<!-- toc -->
- [Summary](#summary)
- [Motivation](#motivation)
  - [Goals](#goals)
  - [Non-Goals](#non-goals)
  - [Use Cases](#use-cases)
  - [Requirements](#requirements)
- [Proposal](#proposal)
  - [Notes and Caveats](#notes-and-caveats)
- [Design Details](#design-details)
- [Design Evaluation](#design-evaluation)
  - [Reusability](#reusability)
  - [Simplicity](#simplicity)
  - [Flexibility](#flexibility)
  - [User Experience](#user-experience)
  - [Performance](#performance)
  - [Risks and Mitigations](#risks-and-mitigations)
  - [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
- [Implementation Plan](#implementation-plan)
  - [Test Plan](#test-plan)
  - [Infrastructure Needed](#infrastructure-needed)
  - [Upgrade and Migration Strategy](#upgrade-and-migration-strategy)
  - [Implementation Pull Requests](#implementation-pull-requests)
- [References](#references)
<!-- /toc -->

## Summary

Tekton supports [sending CloudEvents][tekton-ce-docs] for events associated
with `TaskRuns`, `PipelineRuns` and `CustomRuns`. Events associated with the
latter are generated by a dedicated controller binary, while the former two
are generated by the `TaskRun` and `PipelineRun` controller respectively.

In this TEP we propose to move all the CloudEvents generation logic to the
separate controller. The new controller will support new versions and types
of events:

- Tekton v2 events, which embed `v1.TaskRun` and `v1.PipelineRun` as opposed
  to v1 events which embed the corresponding `v1beta1` resources
- [CDEvents core events][cdevents-core]
- User driven [CDEvents][cdevents] of any kind

## Motivation

When Tekton introduced support for events, the [CloudEvents][cloudevents]
format was chosen as it provides an interoperable standard for the format of
the enveloper of events. At the time, no such standard existed for the
payload. Because of that I created, together with other people on the
[CDF Interoperability Special Interest Group][cdf-sig-interop], the
[CDEvents][cdevents] project. The TEP proposes to adopt that standard, now that
it is available, to enhance Tekton interoperability with other tools in the
CI/CD space.

Rather then introducing CDEvents support in the core Tekton controllers, this
TEP additionally proposes to split the event feature into a dedicated controller,
work which has already started for the `CustomRun` events, and which provides a
better separation of concerns and security benefits, as it separates the secrets
which are needed by `TaskRun` and `PipelineRun` controllers from those required
to successfully deliver events to sinks.

Finally, the new controller enables the development of new features in the area
of events and notification with no or reduced impact on the `TaskRun` and `PipelineRun`
controller, which means the code in those controller remains leaner, and their
scalability is not compromised.

### Goals

- Produce Tekton v2 events through the dedicate event controller
- Produce core CDEvents through the dedicate event controller
- Give task authors a way to trigger additional events from their tasks. Tekton
  has no knowledge about abstractions like builds, artifacts, tests and more,
  that are modelled by CDEvents. Tekton Task authors write task that implement
  such abstraction. Goal of this TEP is to let such authors notify about them
  through CDEvents.
- Give users the ability to select through configuration which event type they
  would like to send, if any
- Give Tekton operators the ability to remove event support from their
  Tekton deployment

### Non-Goals

- Additional messaging features that may be implemented in future, like multiple
  sinks, different event bindings, event signing and more
- Changes to the operator to support disabling the events deployment are welcome,
  but not part of this TEP

### Use Cases

- Notifications: Events produced by Tekton can be used to send notifications via
  different channels (GitHub, Slack, etc)
- Interoperability: CDEvents produced by Tekton can be consumed by other tools to
  trigger the next step in the workflow. Similar events may be triggered by other
  orchestrators like Jenkins and Argo Workflows, letting user switch between tools or
  use a collection of them more easily
- Observability and Audit Trail: Events generated by Tekton can be collected for
  observability purposes along with events generated by other tools in the toolchain.
  These stored events constitute an evidence store can be used to build audit trails,
  visualize workflows, produce metrics
- As a Task author I want to declare the purpose of my task according to the CDEvents
  specification. As a Pipeline observer I want to know what tasks are performed in
  CI/CD pipelines orchestrated by Tekton, according to the CDEvents specification.
  Tekton is a non-opinionated pipeline orchestrator that allow workflow author to
  automated any kind of Task in the CI/CD space (and beyond). Today the purpose of
  the Tasks is usually transparent for Tekton: there is no concept of build, test,
  CVE scan or deployment in Tekton. The Tekton community is working on the "artifact"
  abstraction, but it's not available yet.

### Requirements

- Tekton operators can select which formats of events are produced by Tekton, with
  one or more options available across Tekton v1, Tekton v2 and CDEvents
- Tekton operators can disable events completely or enable events with separation
  of permissions between the pipeline reconcilers and event emitters
- Tekton task authors can send CDEvents using data available during the task execution
- Tekton task authors can send CDEvents by exposing the required type and data through
  an interface to be defined

## Proposal

The events controller is made of three controllers bundled together in one binary,
one for each resource type: `TaskRun`, `PipelineRun` and `CustomRun`. It's deployed
through a dedicated deployment and service, like today and it's part of the standard
release. The operator may decide to provide a configuration option to skip its
deployment.

Each controller is read-only and uses and in-memory LRU cache to keep track of events
that have been already sent. The structure of the cache will be altered to make it
easier to discover all events associated with a certain resource.
Rather than storing the event tuple as key, the resource will be the cache key,
identified in cache by the tuple `resourceKind`, `resourceNamespace` and
`resourceName`. Each key will be associated with a list of the event types sent for
that resource.

The main `TaskRun` and `PipelineRun` controllers today rely on the difference before
the `Condition` before and after reconcile to decide which events to send, if any.
The external controllers may only rely on the information available in the status,
and the list of events in the cache, so the events sent will have to be slightly adapted
accordingly:

| Resource      | Condition | Reason    | Current Event  | New Event | CDEvent  | Notes |
|---------------|-----------|-----------|----------------|-----------|----------|-------|
| Any           | None      | None      | None           | `queued`  | `queued` | When the resource has no status, we know that it has been queued, but we don't know when the main controller will pick it up|
| Any           | `Unknown` | `Started` | `started`      | `started` | `started` | The `Started` reason will only be visible by the controller is the main controller was not able to start running its resources in the same reconcile cycle |
| `TaskRun`, `PipelineRun` | `Unknown` | `Running` | `running` | `started`, `running` or None | `started` or None | If the `started` event was not sent yet, it is sent. If the `running` event was not sent yet, it is sent. If both events were sent already, the `running` event is sent only if there was a change in the `Condition` compared to the last `running` event sent |
| `TaskRun`, `PipelineRun` | `Unknown` | Any but `Running` | `unknown` | `started`, `unknown` or None | `started` or None | If the `started` event was not sent yet, it is sent. If the `unknown` event was not sent yet, it is sent. If both events were sent already, the `unknown` event is sent only if there was a change in the `Condition` compared to the last `unknown` event sent |
| `CustomRun` | `Unknown` | Any | `running` | `started`, `running` | `started` or None | If the `started` event was not sent yet, it is sent. We cannot make assumptions about how `Reason` and `Message` are used by the custom run controller, so always send a `running` event |
| Any         | `Succeed` | Any | `successful` | `successful` | `finished` | The `finished` CDEvent include the `Condition` in the `outcome` field |
| Any         | `Failed` | Any | `failed` | `failed` | `finished` | The `finished` CDEvent include the `Condition` in the `outcome` field |

Since the logic for sending events depends on the content of the cache, it's important
for the cache to be updated **in order**.

### Notes and Caveats

N/A

## Design Details

Example configuration:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-events
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/instance: default
    app.kubernetes.io/part-of: tekton-pipelines
data:
  # formats contains a comma separated list of event formats to be used
  # the only format supported today is "tektonv1". An empty string is not
  # a valid configuration. To disable events, do not specify the sink.
  formats: "tektonv1,cdevents"

  # sink contains the event sink to be used for TaskRun, PipelineRun and
  # CustomRun. If no sink is specified, no CloudEvent is generated.
  # This setting supercedes the "default-cloud-events-sink" from the
  # "config-defaults" config map
  sink: "https://events.sink/cdevents"
```

Example CDEvent:

```yaml
{
  "context": {
    "version": "0.3.0",
    "id": "271069a8-fc18-44f1-b38f-9d70a1695819",
    "source": "/apis/tekton.dev/v1/namespaces/default/taskrun/print-date-q4hv8",
    "type": "dev.cdevents.taskrun.finished.0.1.1",
    "timestamp": "2023-03-20T14:27:05.315384Z"
  },
  "subject": {
    "id": "print-date-q4hv8",
    "source": "/apis/tekton.dev/v1/namespaces/default/taskrun/print-date-q4hv8",
    "type": "taskRun",
    "content": {
      "taskName": "<embedded>",
      "url": "https://tekton.dashboard/print-date-q4hv8"
    }
  },
  "customData": {
    apiVersion: tekton.dev/v1
    kind: TaskRun
    metadata:
      annotations:
        pipeline.tekton.dev/release: 65b0eee-dirty
      creationTimestamp: "2023-07-04T09:39:51Z"
      generateName: print-date-
      generation: 1
      labels:
        app.kubernetes.io/managed-by: tekton-pipelines
      name: print-date-q4hv8
      namespace: default
      resourceVersion: "341953"
      uid: 99cde96f-d919-4abf-bbd6-026a343b79d7
    spec:
      serviceAccountName: default
      taskSpec:
        description: |
          A simple task that prints the date.
        results:
        - description: The current date in unix timestamp format
          name: current-date-unix-timestamp
          type: string
        - description: The current date in human readable format
          name: current-date-human-readable
          type: string
        steps:
        - computeResources: {}
          image: bash:latest
          name: print-date-unix-timestamp
          script: |
            #!/usr/bin/env bash
            date +%s | tee $(results.current-date-unix-timestamp.path)
        - computeResources: {}
          image: bash:latest
          name: print-date-human-readable
          script: |
            #!/usr/bin/env bash
            date | tee $(results.current-date-human-readable.path)
      timeout: 1h0m0s
    status:
      completionTime: "2023-07-04T09:40:03Z"
      conditions:
      - lastTransitionTime: "2023-07-04T09:40:03Z"
        message: All Steps have completed executing
        reason: Succeeded
        status: "True"
        type: Succeeded
      podName: print-date-q4hv8-pod
      provenance:
        featureFlags:
          AwaitSidecarReadiness: true
          DisableAffinityAssistant: false
          DisableCredsInit: false
          EnableAPIFields: beta
          EnableProvenanceInStatus: true
          EnableTektonOCIBundles: false
          EnforceNonfalsifiability: ""
          MaxResultSize: 4096
          RequireGitSSHSecretKnownHosts: false
          ResultExtractionMethod: termination-message
          RunningInEnvWithInjectedSidecars: true
          ScopeWhenExpressionsToTask: false
          SendCloudEventsForRuns: false
          SetSecurityContext: false
          VerificationNoMatchPolicy: ignore
      results:
      - name: current-date-unix-timestamp
        type: string
        value: |
          1688463601
      - name: current-date-human-readable
        type: string
        value: |
          Tue Jul  4 09:40:02 UTC 2023
      startTime: "2023-07-04T09:39:51Z"
      steps:
      - container: step-print-date-unix-timestamp
        imageID: docker.io/library/bash@sha256:1ea30d9b65797fbae4787f6188796e7189371019031958a167423d347d32eada
        name: print-date-unix-timestamp
        terminated:
          containerID: containerd://a8e8bcdd0f15dfbc98e0f3779bc16609dd04b84c7b0c0008f38c5a16136bc11d
          exitCode: 0
          finishedAt: "2023-07-04T09:40:01Z"
          message: '[{"key":"current-date-unix-timestamp","value":"1688463601\n","type":1}]'
          reason: Completed
          startedAt: "2023-07-04T09:40:01Z"
      - container: step-print-date-human-readable
        imageID: docker.io/library/bash@sha256:1ea30d9b65797fbae4787f6188796e7189371019031958a167423d347d32eada
        name: print-date-human-readable
        terminated:
          containerID: containerd://d81697777ce38e2e461c388fbebbec5c925d03a85169d3c98e66da83ebe5bd27
          exitCode: 0
          finishedAt: "2023-07-04T09:40:02Z"
          message: '[{"key":"current-date-human-readable","value":"Tue Jul  4 09:40:02
            UTC 2023\n","type":1},{"key":"current-date-unix-timestamp","value":"1688463601\n","type":1}]'
          reason: Completed
          startedAt: "2023-07-04T09:40:02Z"
      taskSpec:
        description: |
          A simple task that prints the date.
        results:
        - description: The current date in unix timestamp format
          name: current-date-unix-timestamp
          type: string
        - description: The current date in human readable format
          name: current-date-human-readable
          type: string
        steps:
        - computeResources: {}
          image: bash:latest
          name: print-date-unix-timestamp
          script: |
            #!/usr/bin/env bash
            date +%s | tee /tekton/results/current-date-unix-timestamp
        - computeResources: {}
          image: bash:latest
          name: print-date-human-readable
          script: |
            #!/usr/bin/env bash
            date | tee /tekton/results/current-date-human-readable
    }
  }
}
```

## Design Details

### Events Controller Structure

Tekton today has an event controller, deployed as a separate binary, which is used to send
events for `v1beta1.CustomRuns`. The same binary will include controllers for three resources:
`v1.TaskRun`, `v1.PipelineRun` and `v1beta1.CustomRuns`. Since most of the functionality is
identical for the three controllers and reconcilers, most of the logic will be included in
shared packages. The new `reconcile/notifications/runtimeobject.go` will include shared reconciler
functions, and the existing `reconcile/events` will continue to include the event rendering
and delivery functionality.

We will use the `v1beta1.RunObject` to treat the three resource types consistently:

```golang
type RunObject interface {
	// Object requires GetObjectKind() and DeepCopyObject()
	runtime.Object

	// ObjectMetaAccessor requires a GetObjectMeta that returns the ObjectMeta
	metav1.ObjectMetaAccessor

	// GetStatusCondition returns a ConditionAccessor
	GetStatusCondition() apis.ConditionAccessor

	IsSuccessful() bool
	IsCancelled() bool
	HasStarted() bool
	IsDone() bool
}
```

`ReconcileKind` method will be as simple as:

```golang
// ReconcileKind oberves the resource conditions and triggers notifications accordingly
func (c *Reconciler) ReconcileKind(ctx context.Context, taskRun *v1.TaskRun) pkgreconciler.Event {
	return notifications.ReconcileRuntimeObject(ctx, c, taskRun)
}
```

### Cache Design

We will use a more advanced cache library, `github.com/allegro/bigcache/v3`, which provides
better performance and reduced need for garbage collection.
The cache currently is used to store a representation of the events that have been sent
already. This will be changed to storing an hash of a resource and its condition, that in
most cases can be used to easily decide whether a certain key needs to be reconciled or not.

```golang
// ObjectKey is the object condition cache key which combines condition and object kind, namespace and name
func ObjectKey(object v1beta1.RunObject) (string, error) {
  (...)
	return hash(fmt.Sprintf("%s/%s/%s/%s/%s/%s/%s/%s",
		condition.Status,
		condition.Reason,
		condition.Message,
		object.GetObjectKind().GroupVersionKind().Group,
		object.GetObjectKind().GroupVersionKind().Version,
		object.GetObjectKind().GroupVersionKind().Kind,
		object.GetObjectMeta().GetNamespace(),
		object.GetObjectMeta().GetName()))
}
```

### Events Logic

Tekton events include "start", "running", "unknown", "succeeded" and "failed".
The switch between "start" and "running" may happen in a single run of the core reconciler,
and thus it is more complex to achieve for an external observer.
A better model is provided by the CDEvents list of events, which include "queued", "started"
and "finished". To mirror that, we will introduce a new "queued" Tekton event, which will be
sent when no condition at all is set on a resource.

For backwards compatibility we need to continue to produce both the "start" and
"running" events, which means that in some cases those two events will have to be sent during
a single events controller reconcile cycle:

```
if (condition is set) {
  if (resource is not running) {
    send start event
    store start event in cache
  } else {
    // resource is running
    if !(start event in cache) {
      send start event
      store start event in cache
    }
    send running event
  }
}
```

### CDEvents Design

This section covers the following areas:

- the data required for sending CDEvents
- when events may be sent, whether that's Tekton driven or user driven
- the interface available to users to pass the data
- the mechanism used by the events controller to access it

There are a few different options described, which are not necessarily mutually exclusive,
i.e. they could be both implemented to give users a richer set of features.

#### Data Required From Users

CDEvents are composed of a three main sections: `context`. `subject` and `customData`.
The `context` has a fixed structure, e.g.

```json
  "context": {
    "version": "0.3.0",
    "id": "271069a8-fc18-44f1-b38f-9d70a1695819",
    "source": "/event/source/123",
    "type": "dev.cdevents.artifact.packaged.0.1.1",
    "timestamp": "2023-03-20T14:27:05.315384Z"
  },
```

The only field where user input is strictly required is the type. Type is made of a fixed
prefix `dev.cdevents`, a subject e.g. `artifact`, a predicate e.g. `packaged` and a version.
The version part e.g. `0.1.1` is controller by Tekton, so subject and predicate must be
provided by the user.

The structure of `subject` has some common fields, `id`, `source` and `type`, while 
`subject.content` depends on subject and predicate, for instance:

```json
  "subject": {
    "id": "pkg:golang/mygit.com/myorg/myapp@234fd47e07d1004f0aed9c",
    "source": "/event/source/123",
    "type": "artifact",
    "content": {
      "change": {
        "id": "myChange123",
        "source": "my-git.example/an-org/a-repo"
      }
    }
  }
```

The `subject.id` must be provided by the users, as well as the `subject.content` section.

Finally, [`customData`][cdevents-custom-data] hosts user defined content, which can be JSON,
or any other content type as long as it's base64 encoded.

#### When Events Are Sent

There are several options when it comes to sending events, the tables below captures them
and some considerations for each. The main distinction is between Tekton controller and user
controlled. 

For Tekton controlled events, the user provides any data required for sending the events,
and the Tekton controllers send the events based on the status of resources. This is how
events are sent today.

For user controller events, user decide when an event is sent, so they to have to ensure that
the flow of execution allows for the event to be sent. Tekton may provide some
interface to let users specify the data required and let Tekton send the events.
Alternatively, events can be sent by the user directly, which is possible today. It gives
users maximum flexibility but it also leaves the heavy-lifting of sending events to them.

| `TaskRun`/`CustomRun` | Controlled by | Trigger | Data Available | Example Events |
|:----------------------|:-------------:|:-------:|:--------------:|:--------------:|
| Before Start | User | Dedicated resource in the Pipeline | Used defined | Any |
| Start | Tekton | Resource Created | Annotations, Parameters | Build Started, TestSuiteRun Started |
| Running | Tekton | Condition Changed, Unknown | Annotations, Parameters | |
| Running | User | Event requested by user | Any data available in the step context | Any |
| End | Tekton | Condition Changed, True or False | Annotations, Parameters, Results | Build Finished, Artifact Packaged, Service Deployed |
| After End | User | Dedicated resource in the Pipeline | Any available in the context, results from previous Tasks| Any |

#### User Interface

TBD

#### Events Controller Interface

##### Resource Status

The events controller sends CDEvents based on the input it receives through the status of
the resources `TaskRun`, `PipelineRun` and `CustomRun` - more specifically, events can only
be sent when a change happens in the `Condition` of one of these resources.
In addition, the data required to send an event should be stored in the status of the
resource for the events controller to consume.


##### Custom Resource

The events controller sends CDEvents based on custom resources. The custom resources contain
all the user data required to send the events, for instance:

```yaml
apiVersion: tekton.dev/v1beta1
kind: CustomRun
metadata:
  generateName: cdevent-
spec:
  ref:
    apiVersion: custom.tekton.dev/v0
    kind: CDEvent
  params:
    - name: context
      value:
        type: dev.cdevents.build.started
    - name: subject
      value:
        id: myBuild123
    - name: subject-content
        pipelineName: myPipeline
        url: http://example.com/myTaskRun123
    - name: data
      value:
        customDataContentType: "application/json"
        customData: "{\"k1\": \"v1\"}"
```

The example `CustomRun` above could be produced by the pipeline controller or a sidecar
running along the workload, depending on the user interface. 
Alternatively, the same `CustomRun` can be embedded by a user in a `Pipeline` definition,
for instance the following sequence of tasks could be define:

- task send "build.started" event
- task execute "build"
- task send "build.finished" event

The disadvantage of this approach though is that it's up to users to ensure that end the
third task is executed and has all the context required from the build task.

#### Triggering of CDEvents

The events controller reacts to updates to the watched resources `status`.

## Design Evaluation

The experimental controller today uses a combination of annotations, parameters and results
to detect that CDEvents should be sent for a specific Task. This can result in a rather verbose
set of annotation that define event type and the name of each input parameter and result to be
used to collect the data required to sent the event. This approach allows for events to be
sent at the start and completion of a Task only.

An alternative implementation could be to provide Task authors with a file system based API,
similar to what is available for results, accessible via variables, which might allow for
events to be sent at any point during the execution of a Task. Such functionality would
require continuous monitoring for the file-system pod to surface the data for the events
controller to produce and send the final event.

### Reusability

The implementation of Tekton v1, v2 and CDEvents core events will be based on the existing
code in `tektoncd/pipeline` and `tektoncd/experimental`.

The support for additional CDEvents format may reuse the strategy in `tektoncd/experimental`
or add new functionality depending on how the feature is designed.

### Simplicity

The proposed feature by default introduces minimal changes to the user experience and
no changes for the Tekton operator.

Operators will gain extra flexibility:
- select the event format
- tune RBAC permissions for the event producing component in Tekton

### Flexibility

This proposal introduces a dependency to the [CDEvents golang SDK][cdevents-go-sdk],
which it turn depends on the `CloudEvents` SDK, which is already a dependency for Tekton,
as well as on the [`package URL (pURL)` go SDK][purl-go-sdk].

### Conformance

There is no conformance requirement associated with events today, even though that's
something we may consider in future. There adoption of CDEvents is an ideal choice
for Tekton conformant system, as the ability to produce CDEvents brings interoperability
value beyond the conformance to the Tekton API.

### User Experience

From a user point of view, Tekton will expand its event functionality
as an opt-in. The only change that over time will be required for
event users will be to use the new config map, once the deprecated
configuration option is removed.

### Performance

Moving CloudEvents to a separated controller reduces the functional
responsibilities of the core controllers and it allows them and the
event controllers to scale independently.

The separated CloudEvents controller does not share the same context
that the the main controllers have; because it must maintain a cache
of the events that have been sent until now, to avoid event duplicates.
The approach used today is to use a per-controller in-memory cache.
The sharding of resources across controllers when scaling horizontally
allows for the cache to be shared too and held in memory.

A simple LRU cache is used in the current implementation. It shall be
considered whether to switch to a [better performing cache library][go-cache-comparison].

### Risks and Mitigations

Events could be used by malicious users to share sensitive information.
This is not a *new* risk though. Filters could be implemented to help
preventing leaks of sensitive data. Best practices can be documented to
help Tekton authors and operators to make the right, secure choices.

### Drawbacks

The event cache is ephemeral, so it is possible that a few events may
be duplicated after a controller restart.

## Alternatives

- Tekton v2 events and CDEvents could be implemented without using a dedicated
  controller for events
- Tekton v1 events could be moved to a dedicated controller for events with no
  support for CDEvents
- Only core CDEvents events could be supported (`TaskRun` and `PipelineRun`
  events)

## Implementation Plan

The most pressing feature for this TEP is the support for Tekton `v1` API
in events, which is done through the introduction of `v2` events. Because
of that, the implementation plan puts that towards the beginning of the
implementation plan:

- Create a dedicated config map for events configuration. Deprecate the current
  settings in the `defaults` config map. Log warning in case of inconsistent
  configuration, and let the config map take over when used
- Relocate the existing CloudEvents logic (v1 events) to the events controller
- Document operational options for the events controller (disable, scale, tune
  RBAC, maintenance)
- Introduce a config flag for the event format to be produced. Initial value
  is `v1` only. The controller may send multiple events if multiple values are
  selected, although only one is available for now
- Restructure the cache module to exclude the event type from the key.
  Update the new cache content based filtering logic accordingly and introduce
  the `v1` queued event for `CustomRuns`
- Move `TaskRun` events (for `v1`) to the external controller
- Move `PipelineRun` events (for `v1`) to the external controller and cleanup
  any logic related to the main controller sending CloudEvents
- Introduce support for `v2` events. Add the `v2` value to the list of valid
  configurations and document the `v2` format. Deprecate the `v1` format.
- Introduce support for core CDEvents (`PipelineRun` and `TaskRun` events) with
  the corresponding configuration flag and documentation
- Introduce support for other CDEvents to let task author emit reacher events
  during pipeline execution


### Test Plan

- Shared testing package for controller unit tests
- Unit tests, reconcile and controller tests for each controller

### Infrastructure Needed

<!--
(optional)

Use this section if you need things from the project or working group.
Examples include a new subproject, repos requested, GitHub details.
Listing these here allows a working group to get the process for these
resources started right away.
-->

### Upgrade and Migration Strategy

<!--
(optional)

Use this section to detail whether this feature needs an upgrade or
migration strategy. This is especially useful when we modify a
behavior or add a feature that may replace and deprecate a current one.
-->

### Implementation Pull Requests

- [New config map](https://github.com/tektoncd/community/pull/1028)
- [Rename customrun package](https://github.com/tektoncd/pipeline/pull/6884)
- [Restructure customrun event controller](https://github.com/tektoncd/pipeline/pull/6889)

## References

- [CloudEvents controller issue in community repo][ce-controller-issue]
- [CloudEvents controller experiment][ce-controller-repo]
- [CloudEvents controller for CustomRuns in separate binary][ce-controller-for-runs]
- [Issue about moving CloudEvents controller to a separate binary][ce-separate-controller-issue]

[ce-controller-issue]: https://github.com/tektoncd/community/issues/435
[ce-controller-repo]: https://github.com/tektoncd/experimental/tree/main/cloudevents
[ce-controller-for-runs]: https://github.com/tektoncd/pipeline/pull/6529
[ce-separate-controller-issue]: https://github.com/tektoncd/pipeline/issues/2944
[tekton-ce-docs]: https://tekton.dev/docs/pipelines/events/
[cdevents-core]: https://github.com/cdevents/spec/blob/v0.3.0/core.md
[cdevents]: https://cdevents.dev
[cloudevents]: https://cloudevents.io
[cdf-sig-interop]: https://github.com/cdfoundation/sig-interoperability
[cdevents-go-sdk]: https://github.com/cdevents/sdk-go
[purl-go-sdk]: https://github.com/package-url/packageurl-go
[go-cache-comparison]: https://medium.com/codex/our-go-cache-library-choices-406f2662d6b
[cdevents-custom-data]: https://github.com/cdevents/spec/blob/v0.3.0/spec.md#cdevents-custom-data
