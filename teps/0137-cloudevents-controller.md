---
status: proposed
title: CloudEvents controller
creation-date: '2023-06-19'
last-updated: '2023-06-19'
authors:
- '@afrittoli'
collaborators: []
---

# TEP-0137: CloudEvents controller
---

<!-- toc -->
- [Summary](#summary)
- [Motivation](#motivation)
  - [Goals](#goals)
  - [Non-Goals](#non-goals)
  - [Use Cases](#use-cases)
  - [Requirements](#requirements)
- [Proposal](#proposal)
  - [Notes and Caveats](#notes-and-caveats)
- [Design Details](#design-details)
- [Design Evaluation](#design-evaluation)
  - [Reusability](#reusability)
  - [Simplicity](#simplicity)
  - [Flexibility](#flexibility)
  - [User Experience](#user-experience)
  - [Performance](#performance)
  - [Risks and Mitigations](#risks-and-mitigations)
  - [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
- [Implementation Plan](#implementation-plan)
  - [Test Plan](#test-plan)
  - [Infrastructure Needed](#infrastructure-needed)
  - [Upgrade and Migration Strategy](#upgrade-and-migration-strategy)
  - [Implementation Pull Requests](#implementation-pull-requests)
- [References](#references)
<!-- /toc -->

## Summary

Tekton supports [sending CloudEvents][tekton-ce-docs] for events associated
with `TaskRuns`, `PipelineRuns` and `CustomRuns`. Events associated with the
latter are generated by a dedicated controller binary, while the former two
are generated by the `TaskRun` and `PipelineRun` controller respectively.

In this TEP we propose to move all the CloudEvents generation logic to the
separate controller. The new controller will support new versions and types
of events:

- Tekton v2 events, which embed `v1.TaskRun` and `v1.PipelineRun` as opposed
  to v1 events which embed the corresponding `v1beta1` resources
- [CDEvents core events][cdevents-core]
- User driven [CDEvents][cdevents] of any kind

## Motivation

When Tekton introduced support for events, the [CloudEvents][cloudevents]
format was chosen as it provides an interoperable standard for the format of
the enveloper of events. At the time, no such standard existed for the
payload. Because of that I created, together with other people on the
[CDF Interoperability Special Interest Group][cdf-sig-interop], the
[CDEvents][cdevents] project. The TEP proposes to adopt that standard, now that
it is available, to enhance Tekton interoperability with other tools in the
CI/CD space.

Rather then introducing CDEvents support in the core Tekton controllers, this
TEP additionally proposes to split the event feature into a dedicated controller,
work which has already started for the `CustomRun` events, and which provides a
better separation of concerns and security benefits, as it separates the secrets
which are needed by `TaskRun` and `PipelineRun` controllers from those required
to successfully deliver events to sinks.

Finally, the new controller enables the development of new features in the area
of events and notification with no or reduced impact on the `TaskRun` and `PipelineRun`
controller, which means the code in those controller remains leaner, and their
scalability is not compromised.

### Goals

- Produce Tekton v2 events through the dedicate event controller
- Produce core CDEvents through the dedicate event controller
- Give task authors a way to trigger additional events from their tasks. Tekton
  has no knowledge about abstractions like builds, artifacts, tests and more,
  that are modelled by CDEvents. Tekton Task authors write task that implement
  such abstraction. Goal of this TEP is to let such authors notify about them
  through CDEvents.
- Give users the ability to select through configuration which event type they
  would like to send, if any
- Give Tekton operators the ability to remove event support from their
  Tekton deployment

### Non-Goals

- Additional messaging features that may be implemented in future, like multiple
  sinks, different event bindings, event signing and more
- Changes to the operator to support disabling the events deployment are welcome,
  but not part of this TEP

### Use Cases

- Notifications: Events produced by Tekton can be used to send notifications via
  different channels (GitHub, Slack, etc)
- Interoperability: CDEvents produced by Tekton can be consumed by other tools to
  trigger the next step in the workflow. Similar events may be triggered by other
  orchestrators like Jenkins and Argo Workflows, letting user switch between tools or
  use a collection of them more easily
- Observability and Audit Trail: Events generated by Tekton can be collected for
  observability purposes along with events generated by other tools in the toolchain.
  These stored events constitute an evidence store can be used to build audit trails,
  visualize workflows, produce metrics
- As a Task author I want to declare the purpose of my task according to the CDEvents
  specification. As a Pipeline observer I want to know what tasks are performed in
  CI/CD pipelines orchestrated by Tekton, according to the CDEvents specification.
  Tekton is a non-opinionated pipeline orchestrator that allow workflow author to
  automated any kind of Task in the CI/CD space (and beyond). Today the purpose of
  the Tasks is usually transparent for Tekton: there is no concept of build, test,
  CVE scan or deployment in Tekton. The Tekton community is working on the "artifact"
  abstraction, but it's not available yet.

### Requirements

- Tekton operators can select which formats of events are produced by Tekton, with
  one or more options available across Tekton v1, Tekton v2 and CDEvents
- Tekton operators can disable events completely or enable events with separation
  of permissions between the pipeline reconcilers and event emitters
- Tekton task authors can send CDEvents using data available during the task execution
- Tekton task authors can send CDEvents by exposing the required type and data through
  an interface to be defined

## Proposal

The events controller is made of three controllers bundled together in one binary,
one for each resource type: `TaskRun`, `PipelineRun` and `CustomRun`. It's deployed
through a dedicated deployment and service, like today and it's part of the standard
release. The operator may decide to provide a configuration option to skip its
deployment.

Each controller is read-only and uses and in-memory LRU cache to keep track of events
that have been already sent. The structure of the cache will be altered to make it
easier to discover all events associated with a certain resource.
Rather than storing the event tuple as key, the resource will be the cache key,
identified in cache by the tuple `resourceKind`, `resourceNamespace` and
`resourceName`. Each key will be associated with a list of the event types sent for
that resource.

The main `TaskRun` and `PipelineRun` controllers today rely on the difference before
the `Condition` before and after reconcile to decide which events to send, if any.
The external controllers may only rely on the information available in the status,
and the list of events in the cache, so the events sent will have to be slightly adapted
accordingly:

| Resource      | Condition | Reason    | Current Event  | New Event | CDEvent  | Notes |
|---------------|-----------|-----------|----------------|-----------|----------|-------|
| Any           | None      | None      | None           | `queued`  | `queued` | When the resource has no status, we know that it has been queued, but we don't know when the main controller will pick it up|
| Any           | `Unknown` | `Started` | `started`      | `started` | `started` | The `Started` reason will only be visible by the controller is the main controller was not able to start running its resources in the same reconcile cycle |
| `TaskRun`, `PipelineRun` | `Unknown` | `Running` | `running` | `started`, `running` or None | `started` or None | If the `started` event was not sent yet, it is sent. If the `running` event was not sent yet, it is sent. If both events were sent already, the `running` event is sent only if there was a change in the `Condition` compared to the last `running` event sent |
| `TaskRun`, `PipelineRun` | `Unknown` | Any but `Running` | `unknown` | `started`, `unknown` or None | `started` or None | If the `started` event was not sent yet, it is sent. If the `unknown` event was not sent yet, it is sent. If both events were sent already, the `unknown` event is sent only if there was a change in the `Condition` compared to the last `unknown` event sent |
| `CustomRun` | `Unknown` | Any | `running` | `started`, `running` | `started` or None | If the `started` event was not sent yet, it is sent. We cannot make assumptions about how `Reason` and `Message` are used by the custom run controller, so always send a `running` event |
| Any         | `Succeed` | Any | `successful` | `successful` | `finished` | The `finished` CDEvent include the `Condition` in the `outcome` field |
| Any         | `Failed` | Any | `failed` | `failed` | `finished` | The `finished` CDEvent include the `Condition` in the `outcome` field |

Since the logic for sending events depends on the content of the cache, it's important
for the cache to be updated **in order**.

### Notes and Caveats

<!--
(optional)

Go in to as much detail as necessary here.
- What are the caveats to the proposal?
- What are some important details that didn't come across above?
- What are the core concepts and how do they relate?
-->


## Design Details

Example configuration:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-events
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/instance: default
    app.kubernetes.io/part-of: tekton-pipelines
data:
  # formats contains a comma separated list of event formats to be used
  # the only format supported today is "tektonv1". An empty string is not
  # a valid configuration. To disable events, do not specify the sink.
  formats: "tektonv1,cdevents"

  # sink contains the event sink to be used for TaskRun, PipelineRun and
  # CustomRun. If no sink is specified, no CloudEvent is generated.
  # This setting supercedes the "default-cloud-events-sink" from the
  # "config-defaults" config map
  sink: "https://events.sink/cdevents"
```

Example CDEvent:

```yaml
{
  "context": {
    "version": "0.3.0",
    "id": "271069a8-fc18-44f1-b38f-9d70a1695819",
    "source": "/apis/tekton.dev/v1/namespaces/default/taskrun/print-date-q4hv8",
    "type": "dev.cdevents.taskrun.finished.0.1.1",
    "timestamp": "2023-03-20T14:27:05.315384Z"
  },
  "subject": {
    "id": "print-date-q4hv8",
    "source": "/apis/tekton.dev/v1/namespaces/default/taskrun/print-date-q4hv8",
    "type": "taskRun",
    "content": {
      "taskName": "<embedded>",
      "url": "https://tekton.dashboard/print-date-q4hv8"
    }
  },
  "customData": {
    apiVersion: tekton.dev/v1
    kind: TaskRun
    metadata:
      annotations:
        pipeline.tekton.dev/release: 65b0eee-dirty
      creationTimestamp: "2023-07-04T09:39:51Z"
      generateName: print-date-
      generation: 1
      labels:
        app.kubernetes.io/managed-by: tekton-pipelines
      name: print-date-q4hv8
      namespace: default
      resourceVersion: "341953"
      uid: 99cde96f-d919-4abf-bbd6-026a343b79d7
    spec:
      serviceAccountName: default
      taskSpec:
        description: |
          A simple task that prints the date.
        results:
        - description: The current date in unix timestamp format
          name: current-date-unix-timestamp
          type: string
        - description: The current date in human readable format
          name: current-date-human-readable
          type: string
        steps:
        - computeResources: {}
          image: bash:latest
          name: print-date-unix-timestamp
          script: |
            #!/usr/bin/env bash
            date +%s | tee $(results.current-date-unix-timestamp.path)
        - computeResources: {}
          image: bash:latest
          name: print-date-human-readable
          script: |
            #!/usr/bin/env bash
            date | tee $(results.current-date-human-readable.path)
      timeout: 1h0m0s
    status:
      completionTime: "2023-07-04T09:40:03Z"
      conditions:
      - lastTransitionTime: "2023-07-04T09:40:03Z"
        message: All Steps have completed executing
        reason: Succeeded
        status: "True"
        type: Succeeded
      podName: print-date-q4hv8-pod
      provenance:
        featureFlags:
          AwaitSidecarReadiness: true
          DisableAffinityAssistant: false
          DisableCredsInit: false
          EnableAPIFields: beta
          EnableProvenanceInStatus: true
          EnableTektonOCIBundles: false
          EnforceNonfalsifiability: ""
          MaxResultSize: 4096
          RequireGitSSHSecretKnownHosts: false
          ResultExtractionMethod: termination-message
          RunningInEnvWithInjectedSidecars: true
          ScopeWhenExpressionsToTask: false
          SendCloudEventsForRuns: false
          SetSecurityContext: false
          VerificationNoMatchPolicy: ignore
      results:
      - name: current-date-unix-timestamp
        type: string
        value: |
          1688463601
      - name: current-date-human-readable
        type: string
        value: |
          Tue Jul  4 09:40:02 UTC 2023
      startTime: "2023-07-04T09:39:51Z"
      steps:
      - container: step-print-date-unix-timestamp
        imageID: docker.io/library/bash@sha256:1ea30d9b65797fbae4787f6188796e7189371019031958a167423d347d32eada
        name: print-date-unix-timestamp
        terminated:
          containerID: containerd://a8e8bcdd0f15dfbc98e0f3779bc16609dd04b84c7b0c0008f38c5a16136bc11d
          exitCode: 0
          finishedAt: "2023-07-04T09:40:01Z"
          message: '[{"key":"current-date-unix-timestamp","value":"1688463601\n","type":1}]'
          reason: Completed
          startedAt: "2023-07-04T09:40:01Z"
      - container: step-print-date-human-readable
        imageID: docker.io/library/bash@sha256:1ea30d9b65797fbae4787f6188796e7189371019031958a167423d347d32eada
        name: print-date-human-readable
        terminated:
          containerID: containerd://d81697777ce38e2e461c388fbebbec5c925d03a85169d3c98e66da83ebe5bd27
          exitCode: 0
          finishedAt: "2023-07-04T09:40:02Z"
          message: '[{"key":"current-date-human-readable","value":"Tue Jul  4 09:40:02
            UTC 2023\n","type":1},{"key":"current-date-unix-timestamp","value":"1688463601\n","type":1}]'
          reason: Completed
          startedAt: "2023-07-04T09:40:02Z"
      taskSpec:
        description: |
          A simple task that prints the date.
        results:
        - description: The current date in unix timestamp format
          name: current-date-unix-timestamp
          type: string
        - description: The current date in human readable format
          name: current-date-human-readable
          type: string
        steps:
        - computeResources: {}
          image: bash:latest
          name: print-date-unix-timestamp
          script: |
            #!/usr/bin/env bash
            date +%s | tee /tekton/results/current-date-unix-timestamp
        - computeResources: {}
          image: bash:latest
          name: print-date-human-readable
          script: |
            #!/usr/bin/env bash
            date | tee /tekton/results/current-date-human-readable
    }
  }
}
```

## Design Evaluation

The experimental controller today uses a combination of annotations, parameters and results
to detect that CDEvents should be sent for a specific Task. This can result in a rather verbose
set of annotation that define event type and the name of each input parameter and result to be
used to collect the data required to sent the event. This approach allows for events to be
sent at the start and completion of a Task only.

An alternative implementation could be to provide Task authors with a file system based API,
similar to what is available for results, accessible via variables, which might allow for
events to be sent at any point during the execution of a Task. Such functionality would
require continuous monitoring for the file-system pod to surface the data for the events
controller to produce and send the final event.

### Reusability

The implementation of Tekton v1, v2 and CDEvents core events will be based on the existing
code in `tektoncd/pipeline` and `tektoncd/experimental`.

The support for additional CDEvents format may reuse the strategy in `tektoncd/experimental`
or add new functionality depending on how the feature is designed.

### Simplicity

The proposed feature by default introduces minimal changes to the user experience and
no changes for the Tekton operator.

Operators will gain extra flexibility:
- select the event format
- tune RBAC permissions for the event producing component in Tekton

### Flexibility

This proposal introduces a dependency to the [CDEvents golang SDK][cdevents-go-sdk],
which it turn depends on the `CloudEvents` SDK, which is already a dependency for Tekton,
as well as on the [`package URL (pURL)` go SDK][purl-go-sdk].

### Conformance

There is no conformance requirement associated with events today, even though that's
something we may consider in future. There adoption of CDEvents is an ideal choice
for Tekton conformant system, as the ability to produce CDEvents brings interoperability
value beyond the conformance to the Tekton API.

### User Experience

<!--
(optional)

Consideration about the user experience. Depending on the area of change,
users may be Task and Pipeline editors, they may trigger TaskRuns and
PipelineRuns or they may be responsible for monitoring the execution of runs,
via CLI, dashboard or a monitoring system.

Consider including folks that also work on CLI and dashboard.
-->

### Performance

Moving CloudEvents to a separated controller reduces the functional
responsibilities of the core controllers and it allows them and the
event controllers to scale independently.

The separated CloudEvents controller does not share the same context
that the the main controllers have; because it must maintain a cache
of the events that have been sent until now, to avoid event duplicates.
The approach used today is to use a per-controller in-memory cache.
The sharding of resources across controllers when scaling horizontally
allows for the cache to be shared too and held in memory.

A simple LRU cache is used in the current implementation. It shall be
considered whether to switch to a [better performing cache library][go-cache-comparison].

### Risks and Mitigations

Events could be used by malicious users to share sensitive information.
This is not a *new* risk though. Filters could be implemented to help
preventing leaks of sensitive data. Best practices can be documented to
help Tekton authors and operators to make the right, secure choices.

### Drawbacks

The event cache is ephemeral, so it is possible that a few events may
be duplicated after a controller restart.

## Alternatives

- Tekton v2 events and CDEvents could be implemented without using a dedicated
  controller for events
- Tekton v1 events could be moved to a dedicated controller for events with no
  support for CDEvents
- Only core CDEvents events could be supported (`TaskRun` and `PipelineRun`
  events)


## Implementation Plan

The most pressing feature for this TEP is the support for Tekton `v1` API
in events, which is done through the introduction of `v2` events. Because
of that, the implementation plan puts that towards the beginning of the
implementation plan:

- Create a dedicated config map for events configuration. Deprecate the current
  settings in the `defaults` config map. Log warning in case of inconsistent
  configuration, and let the config map take over when used
- Relocate the existing CloudEvents logic (v1 events) to the events controller
- Document operational options for the events controller (disable, scale, tune
  RBAC, maintenance)
- Introduce a config flag for the event format to be produced. Initial value
  is `v1` only. The controller may send multiple events if multiple values are
  selected, although only one is available for now
- Restructure the cache module to exclude the event type from the key.
  Update the new cache content based filtering logic accordingly and introduce
  the `v1` queued event for `CustomRuns`
- Move `TaskRun` events (for `v1`) to the external controller
- Move `PipelineRun` events (for `v1`) to the external controller and cleanup
  any logic related to the main controller sending CloudEvents
- Introduce support for `v2` events. Add the `v2` value to the list of valid
  configurations and document the `v2` format. Deprecate the `v1` format.
- Introduce support for core CDEvents (`PipelineRun` and `TaskRun` events) with
  the corresponding configuration flag and documentation
- Introduce support for other CDEvents to let task author emit reacher events
  during pipeline execution


### Test Plan

- Shared testing package for controller unit tests
- Unit tests, reconcile and controller tests for each controller

### Infrastructure Needed

<!--
(optional)

Use this section if you need things from the project or working group.
Examples include a new subproject, repos requested, GitHub details.
Listing these here allows a working group to get the process for these
resources started right away.
-->

### Upgrade and Migration Strategy

<!--
(optional)

Use this section to detail whether this feature needs an upgrade or
migration strategy. This is especially useful when we modify a
behavior or add a feature that may replace and deprecate a current one.
-->

### Implementation Pull Requests

- [New config map](https://github.com/tektoncd/community/pull/1028)
- [Rename customrun package](https://github.com/tektoncd/pipeline/pull/6884)
- [Restructure customrun event controller](https://github.com/tektoncd/pipeline/pull/6889)

## References

- [CloudEvents controller issue in community repo][ce-controller-issue]
- [CloudEvents controller experiment][ce-controller-repo]
- [CloudEvents controller for CustomRuns in separate binary][ce-controller-for-runs]
- [Issue about moving CloudEvents controller to a separate binary][ce-separate-controller-issue]

[ce-controller-issue]: https://github.com/tektoncd/community/issues/435
[ce-controller-repo]: https://github.com/tektoncd/experimental/tree/main/cloudevents
[ce-controller-for-runs]: https://github.com/tektoncd/pipeline/pull/6529
[ce-separate-controller-issue]: https://github.com/tektoncd/pipeline/issues/2944
[tekton-ce-docs]: https://tekton.dev/docs/pipelines/events/
[cdevents-core]: https://github.com/cdevents/spec/blob/v0.3.0/core.md
[cdevents]: https://cdevents.dev
[cloudevents]: https://cloudevents.io
[cdf-sig-interop]: https://github.com/cdfoundation/sig-interoperability
[cdevents-go-sdk]: https://github.com/cdevents/sdk-go
[purl-go-sdk]: https://github.com/package-url/packageurl-go
[go-cache-comparison]: https://medium.com/codex/our-go-cache-library-choices-406f2662d6b
